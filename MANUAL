C++ Builtem
Version 1.0.0-devel

Introduction
============

C++ Builtem is a cross-platform Makefile-based build system for C++11 released
under MPL 2.0 license (http://www.mozilla.org/MPL/2.0/). It is versioned using
Semantic Versioning (http://semver.org/).

Features:
- can create binaries, static libraries and shared libraries
- various build modes that can be used at the same time
  - normal
  - debug
  - profile (only with gcc)
  - release
- automatic dependency generation

Supported platforms and compilers:
- gcc on Linux
- clang on OS X
- tdm-gcc on Windows (either cmd.exe or sh shell)
- Visual C++ on Windows (either cmd.exe or sh shell)

The C++-Builtem also contains several (cross)compilers for Linux. For every
(cross)compiler, there are instructions (or scripts) how to install it and also
a shell script that runs make using it.
- gcc 4.9.2 compiled against libc from Debian Lenny using crosstool-ng
- tdm-gcc 4.9.2
- Visual C++ 2013
- remote clang execution on OS X using SSH

Copyright 2014 by Institute of Formal and Applied Linguistics, Faculty of
Mathematics and Physics, Charles University in Prague, Czech Republic.

C++ Builtem repository http://github.com/ufal/cpp_builtem is hosted on GitHub.


Makefile.builtem API Reference
==============================

To use Makefile.builtem include it at the beginning of a user Makefile. Although
it defines several targets, it does not define a default goal, so the first
target in the user Makefile is still the default goal.

Using several build controlling variables, Makefile.builtem defines implicit
rules for compiling object files and provides three linking methods
(executables, dynamic libraries, library archives). The dependencies of object
files are tracked automatically.

The sources can be located in subdirectories (which has to be either fully
specified or VPATH or vpath can be used). The object files are created in a
.build directory using a name mangling scheme which encodes the subdirectory of
the input file, compilation platform, compilation mode and code bitness. This
allows object files for different modes (release/profile) and different
platforms to coexist.

During linking, Makefile.builtem makes sure a target is relinked if different
compilation platform, mode or bitness is used. Nevertheless, for this to work,
the link command must be defined in a regular rule or static pattern rule, not
in an implicit rule (the .PHONY is used to force the linking which does not work
with implicit rules).

The Makefile.builtem works for either any Posix Shell or Windows CMD shell. To
that end, several file manipulation methods are defined so that they are shell
independent. Please use slash as a path separator, it is converted to backslash
when needed.


Variables Controlling the Build
-------------------------------

The main variables controlling the build (they are most commonly specified on
the make command line) are the following:
- PLATFORM:
  The platform to use. Available platforms are:
  - linux, linux-gcc: Linux platform using gcc compiler.
  - win, win-gcc: Windows platform using gcc compiler (TDM-GCC is tested
    thoroughly, although MinGW-w64 works too). The shell can be either Posix or
    CMD.
  - win-vs: Windows platform using Visual C++ 2013 compiler or newer. The CMD
    shell is thoroughly tested, but Posix shell should probably work too.

    The automatic dependency tracking uses the /showIncludes option and uses
    cl_deps binary to parse its output to Makefile format. The
    .build/cl_deps.cpp is created by the Makefile.builtem and compiled
    automatically into .build/cl_deps.exe binary. Note that if 64-bit compiler
    is used, the cl_deps is also 64-bit, which might break the build if it is
    performed on 32-bit system. In that case, first build the .build/cl_deps.exe
    using 32-bit compiler.

    Note that for this platform bitness must be always specified
  - osx, osx-clang: OS X platform using clang compiler.
  If the platform is not specified, one of linux, win and osx is detected
  automatically.

- CXX:
  The compiler to use. If not defined, it is set according to PLATFORM to either
  g++, clang++ or cl.

- PLATFORM_SHELL:
  The shell to use. Supported shells are:
  - sh: Use Posix-compatible shell.
  - cmd: Use Windows CMD shell. Even with this shell use slash as path
    separator. It is automatically converted to backslash where necessary.
  If not specified, it is detected automatically.

- MODE:
  Compilation mode to use. Available compilation modes are:
  - normal: Normal build. Optimizations are used, assertions are evaluated, but
    usually no debug information is produced. Shared version of C++ runtime is
    used (except for Windows).
  - release: Release build. Link time optimizations are used, assertions are
    not evaluated, the targets are stripped and static version of C++ runtime is
    used (except for OS X).
  - debug: Debug build. Debug information is produced (with optimizations still
    in place). In addition, libstdc++ debugging is also switched on.
  - profile: Profile build supported only with gcc compiler. It is a normal
    build with debug information and profiling enabled.
  The compilation mode defaults to normal if not specified.

- BITS:
  The bitness of the build. Can be either unspecified (then the default of the
  compiler is used) or one of:
  - 32: Use 32-bit architecture.
  - 64: Use 64-bit architecture.
  - 32+64: Use both 32-bit and 64-bit architecture. Usable on OS X only.
  Note that when using Visual C++, bitness must always be specified. That is
  caused by the fact that when specifying link subsystem, it is either 5.01 for
  32-bit or 5.02 for 64-bit architecture. According to documentation 5 should
  also work (and would probably automatically append valid minor version), but
  the linker does not accept it.


Compilation Options
-------------------

The compilation option can be specified using the following variables:
- C_FLAGS: Compiler flags used in every compilation.
- DYN_C_FLAGS: Compiler flags appended for objects of dynamic libraries (i.e.
  -fPIC on Linux and /LD[d] with Visual C++).
- LD_FLAGS: Linker flags used in every linking. Note that the semantics is
  slightly different For Visual C++ and other compilers. For Visual C++, the
  linker flags are the last parameters of the command line after the /link
  option (i.e. they are really passed to the linker). For other compilers, the
  linker flags are just the last parameters of the command line (i.e. they had
  to be prefixed with -Wl, if they are real linker flags). This is in accordance
  with how linker flags are interpreted in the respective platforms.
- DYN_LD_FLAGS: Linker flags appended for dynamic libraries linking (i.e.
  -shared on Linux and -dynamiclib on OS X).

They can be specified either globally or only for some targets (using
target-specific variable assignments). Note that in Makefile.builtem these
variables are always appended to, so the initial values from environment or make
command line are respected.


Linking Commands
----------------

- link
- link_dyn
- archive


Platform Target Names
---------------------

Because object files, executables and libraries have different names on
different platforms, you should use the following methods:
- $(call obj,file_without_extension)
- $(call dynobj,file_without_extension)
- $(call exe,file_without_extension)
- $(call lib,file_without_extension)
- $(call dynlib,file_without_extension)


Shell Commands
--------------

- mkdir
- touch
- echo
- cp
- rm - allow multiple
- rmdir - allow multiple
